
function find_os() {
    uname_s=i$(uname -s)
    case $uname_s in
        CYGWIN_NT-5.2-WOW64) export OS=winnt;;
        *CYGWIN_NT*) export OS=winnt;;
        *CYGWIN*) export OS=winnt;;
        *darwin*) export OS=macosx;;
        *Darwin*) export OS=macosx;;
        *linux*) export OS=linux;;
        *Linux*) export OS=linux;;
        *NetBSD*) export OS=netbsd;;
        *FreeBSD*) export OS=freebsd;;
        *OpenBSD*) export OS=openbsd;;
        *DragonFly*) export OS=dragonflybsd;;
    esac
}
find_os

function find_architecture() {
    uname_m=$(uname -m)
    case $uname_m in
        i386) export ARCH=x86;;
        i686) export ARCH=x86;;
        amd64) export ARCH=x86;;
        ppc64) export ARCH=ppc;;
        *86) export ARCH=x86;;
        *86_64) export ARCH=x86;;
        "Power Macintosh") export ARCH=ppc;;
    esac
}
find_architecture

function installed() {
    [[ -n $(hash "$1") ]]
}

function set_downloader() {
    if installed wget; then
        DOWNLOADER=wget
    else
        DOWNLOADER="curl -O"
    fi
}

function prt_error() {
    echo "$(tput setaf 1)$1$(tput sgr0)"
}

function prt_warn() {
    echo "$(tput setaf 5)$1$(tput sgr0)"
}

function prt() {
    echo "$(tput setaf 2)$1$(tput sgr0)"
}

function source_if_exists() {
    if test -e "$1"; then
        . "$1"
    else
        prt_warn "Couldn't source $1"
    fi
}

function contains() {
    local array="$1[@]"
    local seeking=$2
    local in=1
    for element in "${!array}"; do
        echo "${element} == ${seeking}";
        if [[ "${element}" == "${seeking}" ]]; then
            in=0
            break
        fi
    done
    return ${in}
}


# pathmunge /path/to/add [after]
function pathmunge () {
    if ! echo "$PATH" | grep -Eq "(^|:)$1($|:)" ; then
       if [[ "$2" = "after" ]] ; then
          export PATH="$PATH:$1"
       else
          export PATH="$1:$PATH"
       fi
    fi
}

# pypathmunge /path/to/add [after]
function pypathmunge () {
    if ! echo "$PYTHONPATH" | grep -Eq "(^|:)$1($|:)" ; then
       if [[ "$2" = "after" ]] ; then
          export PYTHONPATH="$PYTHONPATH:$1"
       else
          export PYTHONPATH="$1:$PYTHONPATH"
       fi
    fi
}


# FIX PERMISSIONS ON NODE
function permission_fix_on_node() {
  sudo chown -R "$(whoami)" ~/.npm
  sudo chown -R "$(whoami)" /usr/local/lib/node_modules
}

# KILL PROC BY NAME
function killnamed () {
  pgrep "$1" | cut -d ' ' -f 2 | xargs kill
}

# ZIP FILE
function zipr() {
  zip -r "$1".zip "$1"
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
    local tmpFile="${*%/}.tar";
    tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

    size=$(
        stat -f"%z" "${tmpFile}" 2> /dev/null; # macOS `stat`
        stat -c"%s" "${tmpFile}" 2> /dev/null;  # GNU `stat`
    );

    local cmd="";
    if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
        # the .tar file is smaller than 50 MB and Zopfli is available; use it
        cmd="zopfli";
    else
        if hash pigz 2> /dev/null; then
            cmd="pigz";
        else
            cmd="gzip";
        fi;
    fi;

    echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`â€¦";
    "${cmd}" -v "${tmpFile}" || return 1;
    [[ -f "${tmpFile}" ]] && rm "${tmpFile}";

    zippedSize=$(
        stat -f"%z" "${tmpFile}.gz" 2> /dev/null; # macOS `stat`
        stat -c"%s" "${tmpFile}.gz" 2> /dev/null; # GNU `stat`
    );

    echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully.";
}

# UNTAR AND GZIP FILES
function untarit() {
  tar -xzvf "$1.gz.tar" "$1"
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
    tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

# LANGUAGE FUNCTIONS --------------------------

# PYTHON

# START PYTHON MAILSERVER
function python_mailserver() {
  local port="${1:-1025}"
  sudo python -m smtpd -n -c DebuggingServer localhost:"$port"
}

# START PYTHON SIMPLEMAILSERVER
function python_simpleserver() {
  local port="${1:-8000}"
  open "http://localhost:${port}/" && python -m SimpleHTTPServer "$port"
}

function remove_all_pyc() {
  find . -name "*.pyc" -exec git rm -f {} \; # REMOVE ALL PYC
}

# COMMIT PENDING CHANGES AND QUOTE ALL ARGS AS MESSAGE
function gg() {
  git commit -v -a -m "$*"
}

# GIT CLONE FROM GITHUB
function gch() {
  git clone "git://github.com/$1/$2.git" "$2"
}

# SETUP A TRACKING BRANCH FROM [REMOTE] [BRANCH_NAME]
function gbt() {
  git branch --track "$2" "$1/$2" && git checkout "$2"
}
# QUICKLY CLOBBER A FILE AND CHECKOUT
function grf() {
  rm "$1"
  git checkout "$1"
}

function pyinstall() {
    openssl_path=$(brew --prefix openssl)
    readline_path=$(brew --prefix readline)
    xcode_path=$(xcrun --show-sdk-path)

    CFLAGS="-I${readline_path}/include -I${openssl_path}/include -I${xcode_path}/usr/include -O2" \
    LDFLAGS="-L${readline_path}/lib -L${openssl_path}/lib -L${xcode_path}/usr/lib" \
    pyenv install "$1"
}
